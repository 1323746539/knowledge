# 开闭原则示例

开闭原则的核心思想是：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。

## 1. 不遵循开闭原则的写法

```javascript
class PaymentProcessor {
    processPayment(paymentType, amount) {
        if (paymentType === 'alipay') {
            // 支付宝支付逻辑
            console.log(`使用支付宝支付 ${amount} 元`);
        } else if (paymentType === 'wechat') {
            // 微信支付逻辑
            console.log(`使用微信支付 ${amount} 元`);
        } else if (paymentType === 'unionpay') {
            // 银联支付逻辑
            console.log(`使用银联支付 ${amount} 元`);
        } else {
            throw new Error('不支持的支付方式');
        }
    }
}

// 使用示例
const processor = new PaymentProcessor();
processor.processPayment('alipay', 100);
processor.processPayment('wechat', 200);
processor.processPayment('unionpay', 300);
```

## 2. 遵循开闭原则但不完全遵循单一职责原则的写法

```javascript
// 支付策略接口
class PaymentStrategy {
    pay(amount) {
        throw new Error('子类必须实现 pay 方法');
    }
}

// 支付宝支付策略
class AlipayStrategy extends PaymentStrategy {
    pay(amount) {
        console.log(`使用支付宝支付 ${amount} 元`);
    }
}

// 微信支付策略
class WechatPayStrategy extends PaymentStrategy {
    pay(amount) {
        console.log(`使用微信支付 ${amount} 元`);
    }
}

// 银联支付策略
class UnionPayStrategy extends PaymentStrategy {
    pay(amount) {
        console.log(`使用银联支付 ${amount} 元`);
    }
}

// 支付处理器（同时负责策略管理和支付处理）
class PaymentProcessor {
    constructor() {
        this.strategies = new Map();
    }

    // 注册支付策略
    registerStrategy(name, strategy) {
        this.strategies.set(name, strategy);
    }

    // 处理支付
    processPayment(paymentType, amount) {
        const strategy = this.strategies.get(paymentType);
        if (!strategy) {
            throw new Error('不支持的支付方式');
        }
        strategy.pay(amount);
    }
}

// 使用示例
const processor = new PaymentProcessor();

// 注册各种支付策略
processor.registerStrategy('alipay', new AlipayStrategy());
processor.registerStrategy('wechat', new WechatPayStrategy());
processor.registerStrategy('unionpay', new UnionPayStrategy());

// 处理支付
processor.processPayment('alipay', 100);
processor.processPayment('wechat', 200);
processor.processPayment('unionpay', 300);
```

## 3. 同时遵循开闭原则和单一职责原则的写法

```javascript
// 支付策略接口
class PaymentStrategy {
    pay(amount) {
        throw new Error('子类必须实现 pay 方法');
    }
}

// 支付宝支付策略
class AlipayStrategy extends PaymentStrategy {
    pay(amount) {
        console.log(`使用支付宝支付 ${amount} 元`);
    }
}

// 微信支付策略
class WechatPayStrategy extends PaymentStrategy {
    pay(amount) {
        console.log(`使用微信支付 ${amount} 元`);
    }
}

// 银联支付策略
class UnionPayStrategy extends PaymentStrategy {
    pay(amount) {
        console.log(`使用银联支付 ${amount} 元`);
    }
}

// 支付策略管理器（单一职责：管理支付策略）
class PaymentStrategyManager {
    constructor() {
        this.strategies = new Map();
    }

    registerStrategy(name, strategy) {
        this.strategies.set(name, strategy);
    }

    getStrategy(name) {
        const strategy = this.strategies.get(name);
        if (!strategy) {
            throw new Error('不支持的支付方式');
        }
        return strategy;
    }
}

// 支付处理器（单一职责：处理支付）
class PaymentProcessor {
    constructor(strategyManager) {
        this.strategyManager = strategyManager;
    }

    processPayment(paymentType, amount) {
        const strategy = this.strategyManager.getStrategy(paymentType);
        strategy.pay(amount);
    }
}

// 使用示例
const strategyManager = new PaymentStrategyManager();

// 注册各种支付策略
strategyManager.registerStrategy('alipay', new AlipayStrategy());
strategyManager.registerStrategy('wechat', new WechatPayStrategy());
strategyManager.registerStrategy('unionpay', new UnionPayStrategy());

// 创建支付处理器
const processor = new PaymentProcessor(strategyManager);

// 处理支付
processor.processPayment('alipay', 100);
processor.processPayment('wechat', 200);
processor.processPayment('unionpay', 300);

// 添加新的支付方式（比如添加京东支付）
class JDpayStrategy extends PaymentStrategy {
    pay(amount) {
        console.log(`使用京东支付 ${amount} 元`);
    }
}

// 注册新的支付策略
strategyManager.registerStrategy('jdpay', new JDpayStrategy());
processor.processPayment('jdpay', 400);
```

## 三种写法的对比分析

1. **不遵循开闭原则的写法**：
   - 每次添加新的支付方式都需要修改 `PaymentProcessor` 类
   - 违反了开闭原则，因为对扩展开放，对修改也开放
   - 代码耦合度高，难以维护
   - 添加新功能时需要修改现有代码，增加了出错的风险

2. **遵循开闭原则但不完全遵循单一职责原则的写法**：
   - 通过策略模式实现开闭原则
   - 新增支付方式只需要创建新的策略类并注册
   - 不需要修改现有的代码
   - 但是 `PaymentProcessor` 类同时负责策略管理和支付处理，违反了单一职责原则

3. **同时遵循开闭原则和单一职责原则的写法**：
   - 将策略管理和支付处理分离到两个独立的类中
   - `PaymentStrategyManager` 专门负责管理支付策略
   - `PaymentProcessor` 专门负责处理支付
   - 每个类都有明确的单一职责
   - 保持了代码的可扩展性和可维护性

## 设计原则的优势

1. **可维护性**：
   - 现有代码不需要修改，降低了引入 bug 的风险
   - 代码结构清晰，每个类职责单一
   - 更容易理解和维护

2. **可扩展性**：
   - 轻松添加新的支付方式
   - 不需要修改现有代码
   - 符合"开-闭"原则

3. **灵活性**：
   - 可以动态注册和更换支付策略
   - 支持运行时添加新的支付方式
   - 策略管理和支付处理可以独立变化

4. **可测试性**：
   - 每个类都是独立的，职责单一
   - 易于编写单元测试
   - 便于模拟不同的支付场景
   - 可以独立测试策略管理和支付处理 